= Контрольная II
:icons: font
:table-caption!:
:cls01ple-caption!:
:source-highlighter: highlightjs
:revealjs_hash: true
:customcss: https://gistcdn.githack.com/fedochet/4ee0f4a2224ecd29a961082a0c63c020/raw/18c107982aba90bb94194c0ac3a8a5ca9bad6782/asciidoc_revealjs_custom_style.css
:revealjs_theme: blood
:stylesheet: main.css
:toc:
:toclevels: 4

== Правила сдачи

Оформлены тут: https://github.com/cpp-practice/moderncpp-course-2425-public/blob/main/docs/controls_flow.md[public/controls_flow]

== Задача 1: Многопоточность [1 балл]

Нам предстоит доработать два класса: `ExecutionQueue` и `Buffer`.

С каждым объектом типа Buffer можно связать очередь исполнения (`ExecutionQueue`) посредством вызова метода `Buffer::move_to_execution_queue`.
Это должно быть можно делать многократно и из произвольных потоков.

Класс `Buffer` имеет метод `post`, добавляющий в буффер задачу. Задача в данном контексте это `std::function<void()>`.
Как только в ассоциированной с буффером `ExecutionQueue` (если она есть!) не оказывается исполняющихся задач, *посланных этим буфером*, буффер отправляет задачу на исполнение в `ExecutionQueue`.
Таким образом, в каждый момент времени в `ExecutionQueue` имеется не более *одной* задачи, посланной определенным буфером (но может быть много задач от разных буферов).

image:https://i.ibb.co/mFMHzCw/buffer-worker.png[]

Если число задач в `Buffer`, ожидающих посылки в `ExecutionQueue`, превышает допустимый максимальный размер очереди, передаваемый как std::optional<size_t> буфферу в конструкторе, то самая старая задача дропается.

=== Детали готовой реализации

Код уже написан, и даже *обычно* проходит тесты (sic! это вообще говоря может быть делом случая! :)), однако не является потокобезопасным. Ваша задача - сделать его таковым!

Особенности реализации:

* `ExecutionQueue` в своем конструкторе заводит поток, в котором синхронно исполняет переданные на вход задачи
* И `ExecutionQueue` и `Buffer` содержат внутри по очереди задач:
** `ExecutionQueue` использует свою очередь для упорядочивания задач из разных буфферов
** `Buffer` использует свою очередь для лимитирования числа тасок

Ограничения готового апи (исправлять их не надо):

* Связь `ExecutionQueue` -> `Buffer` выражена неявно; в api нет способа отвязать очередь от буффера (можно связать буффер с _другой_ очередью)
** Следствие: если буффер меняет очередь исполнения (с q1 на q2), *обе* очереди исполняют накопленные в нем задачи в течение некоторого времени
* Ответственность пользователя — поддерживать живость `ExecutionQueue` до момента, пока буффер не опустошен (хотя `Buffer` и сохраняет очередь себе через `shared_ptr`)
** В тестах это выражено в подчистке: сначала буфферы, затем очереди

=== Доработки кода

Все публичные методы `Buffer` и `ExecutionQuque` должно быть можно вызывать из разных потоков.

Обратите внимание, вы *можете* и даже *должны* добавлять новые поля (примитивы синхронизации) к классам при решении задачи.

== Задача 2: Динамическая библиотека для сериализации [1 балл]

В этой задачке мы хотим написать динамическую библиотеки для чтения-записи структуры `PhoneBook` и RAII-обертку вокруг нее (dll)

=== I. Структура и де/сериализация

* Структурка очень простая, содержит внутри себя всего лишь одну мапу из имени в телефон человека
* Библиотека должна реализовывать интерфейс, описанный в `extern "C"` части заголовочного файла `phonebook.hpp`

[source,cpp]
----
void read_phonebook(PhoneBook* pb, std::istream &in);
void write_phonebook(const PhoneBook* pb, std::ostream &out);
----

* Интерфейс должен позволять сериализовывать и десериализовывать структуру PhoneBook, используя библиотеку `json` ( https://github.com/nlohmann/json[`nlohmann/json`] )
** библиотека уже присутствует в виде *единого* заголовочного файла внутри `./src`
* Код конвертаций поместите в `json_parser.cpp`

=== II. Код в виде библиотеки: загрузчик

* Смоук тест ко второй задаче *никак не линкуется* с динамической библиотекой, которую вы пишете, а загружает динамически и использует лукап функций
* интерфейс загрузчика библиотеки описан в file://./src/task_2/idllloader.hpp[`idllloader.hpp`]
** Обратите внимание на имена таргетов своих библиотек, если они будут отличаться от тех, что предполагаются в тесте, поправьте их в соответствии с тестом (для windows укажите правильные имена в тесте)
* надо дописать код загрузчика *для unix* (`unix/dllloader.hpp`; для windows уже все написано, но не используется в CI)

=== III. Сборка библиотеки
* еще раз: смоук тест ко второй задаче *никак не линкуется* с динамической библиотекой, которую вы пишете, а загружает динамически и использует лукап функций
** это свойство *надо сохранить* (нельзя применять статическую линковку)
* задача: дописать в cmake-файл инструкции по сборке SHARED-библиотеки наряду с `task-2-test`
** таргет надо назвать `json-parser`
** т.к. он использует `nlohmann/json` — потребуется указать дополнительные `include_directories`
** см. директиву https://cmake.org/cmake/help/latest/command/add_library.html#normal[add_library]


== Задача 3: compile-time матрицы [1 балл]

Реализуйте шаблонный класс FixedSizesMatrix, позволяющий проводить матричные вычисления в компайл-тайм. Размеры конкретного объекта матрицы не меняется по ходу выполнения программы, а фиксированы в типе

Необходимый интерфейс:

* класс шаблонен по параметру-типу хранимых данных (T) и двум параметрам-размерам (MxN, пример: `FixedSizesMatrix<int, 2, 3>`)
* конструктор от листа листов `T``, где лист — это std::initializer_list. Ожидается, что во входных данных есть M строк по N элементов, ими и нужно инициализироваться
* конструктор от init-значения типа T — все элементы надо проинициализировать им
* получение данных: `dim1()`, `dim2()`, `get(i, j)`
* `operator==`
* матричные вычисления: `operator+`, `operator*`
* метод `det()`, считающий определитель матрицы — *только* для размеров 2x2 и 3x3, для других матриц метода быть не должно
* вывод в поток через метод `print`, работающий с ostream-объектами

Нюансы:

* Хранить данные необходимо эффективно, в виде непрерывной последовательности памяти
* Все методы, которые возможно, подготовьте для использования в compile-time
